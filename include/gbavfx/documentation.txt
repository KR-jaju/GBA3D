Matrix:
	메모리를 절약하기 위해 3행 4열의 행렬을 사용한다. 곱 순서는 행렬 * 벡터 순
	행렬의 회전부([0:2, 0:2])는 정수부 0비트, 소수부 15비트의 부호있는 16비트 고정소수점을 사용한다.
	행렬의 평행이동부([0:2, 3])는 정수부 7비트, 소수부 8비트의 부호있는 16비트 고정소수점을 사용한다.
	메모리에는 row-major로 요소 당 4바이트를 차지하도록 작성해야한다.
	4바이트 중 상위 2바이트는 하위 2바이트의 sign-extension된 형태여야한다.
	그렇지 않은 경우 동작이 정의되지 않는다 (UB)

Vector:
	벡터는 행렬 곱과의 호환성을 위해 각 요소 정수부 7비트, 소수부 8비트의 부호있는 16비트 고정소수점을 사용한다.
	메모리에는 총 12바이트, x, y, z순으로 요소 당 4바이트를 차지하도록 작성해야한다.
	4바이트 중 상위 2바이트는 하위 2바이트의 sign-extension된 형태여야한다.
	그렇지 않은 경우 동작이 정의되지 않는다 (UB)

PTV(post transform vertex):
	PTV는 정점 변환 (행렬곱 및 원근 변환)이 적용된 결과가 저장되는 포맷이다.
	x, y는 스크린 스페이스 픽셀 좌표이며, 부호 있는 12비트 정수이다.
	z는 깊이로, 부호 없는 8비트 정수, 가능한 범위는 1 ~ 255이다.
	u, v는 텍스쳐 좌표로, 정수부 10비트, 소수부 5비트의 부호 있는 16비트 고정소수점이다.
	(0, 0) ~ (64, 64)가 텍스쳐 하나의 범위로, 넘어가면 texture_wrap_repeat의 효과가 있다.
	PTV는 다음과 같은 메모리 레이아웃을 갖는다.
	struct PTV
	{
		y : 12
		x : 12
		z : 8
		u : 16 (64픽셀, 부호에 1비트, 소수점에 5비트, 정수부에 10비트(최대 16배 스크롤링))
		v : 16
	}; // 총 8바이트

Face:
	면은 정점 3개로 만들어지는 삼각형을 정의하는 포맷이다.
	다음과 같은 메모리 레이아웃을 갖는다.
	struct Face
	{
		i0 : 16
		i1 : 16
		next_face : 11
		texture_id : 5
		i2 : 16
	}; // 총 8바이트
	

PTB(Post Transform Buffer) :
	정점 변환이 완료된 PTV들을 저장하는 버퍼이다.

Interlaced rendering:
	성능을 위해 인터레이싱을 사용하고 있다. 오버드로우가 많을수록 효과가 좋아진다.
	buffer[0]에 그릴 때는, 
	0, 2, 4번째 줄은 buffer[1]에서 복사하고,
	1, 3, 5번째 줄은 배경해서 복사한다.
	그리고 1, 3, 5번째 줄에 폴리곤을 렌더링한다.
	buffer[1]에 그릴 때는 그 반대이다.


